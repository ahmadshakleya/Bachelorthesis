\documentclass[../main.tex]{subfiles}

\setstretch{0.1} % 

\begin{document}

%\chapter{Methods and Materials}
{\let\clearpage\relax\chapter{Methods and Materials}}
\section{Initial Approach Using Ray Tracing in \texttt{C++}}
% Still need to cite references
\textbf{Ray tracing} is a rendering technique that simulates the way light interacts with objects to generate images with high visual realism. Unlike rasterization, which is used in most real-time graphics, ray tracing calculates the color of pixels by tracing the path that light would take as it travels through a scene. This path is traced backwards from the viewer's eye to the light source, a method known as \textit{backward ray tracing}.

The basic principle of ray tracing involves shooting rays from the eye, ideally one ray for each pixel, and determining the color of the object the ray intersects first. This color is then modified based on the material properties of the object and the effects of light sources and other objects between the intersection point and the light sources, such as shadows, reflections, and refractions.

Ray tracing is computationally intensive because each ray may spawn new rays upon interaction with a surface. These secondary rays, which handle reflections, refractions, and shadows, contribute to the realistic portrayal of materials like glass, water, and metals, and effects such as soft shadows and ambient occlusion. This complexity often makes ray tracing less suitable for real-time applications but ideal for applications where visual quality is more important than real-time performance, such as in static image rendering and film production.

The development of more efficient algorithms and the advent of powerful hardware, such as GPUs that can perform ray tracing in real time, have expanded the use of ray tracing in real-time applications, including video games and interactive media. Ray tracing's ability to simulate complex interactions of light makes it a fundamental technique in the pursuit of photorealistic graphics in both cinematic and interactive applications.
% Still need to cite references

Initially, the simulation of optical flat measurements was attempted using a ray tracing technique in C++. Ray tracing is a powerful computational method for simulating the path of light through media. It models the propagation of light rays and their interactions with surfaces, which is particularly useful in optical studies where the understanding of light behavior in precise environments is necessary. However, this approach did not yield successful results due to complexities in accurately modeling the intricate interference patterns that are critical in optical flat evaluations.

\section{Successful Simulation Using Python}
After the initial setbacks, a more successful simulation was developed using Python. This method utilized the concept of intersecting planes with the surface under test (sft). Each plane was separated by half the wavelength of the light transmitted through the optical flat, allowing for the simulation of interference patterns by modeling how these planes interact with the surface irregularities.

\subsection{Python Scripts and GUI Development}
To implement this method, several Python scripts were created:
\begin{itemize}
    \item \textbf{Intersection.py} - Handles the mathematical computation of plane and surface intersections.
    \item \textbf{Gui.py} - A graphical user interface was developed to facilitate the interaction with the simulation, allowing users to adjust parameters and visualize results in real-time.
    \item \textbf{Creating\_image.py, Disk.py, Cylinder.py, Flat\_surface.py, Shape3D.py, STLFigure.py} - These scripts contribute to generating and handling various geometrical shapes and rendering the final 3D images which represent the simulation results.
\end{itemize}

\subsubsection{Detailed Script Descriptions}

\paragraph{Geometric Shape Scripts}
The scripts \texttt{Disk.py}, \texttt{Cylinder.py}, and \texttt{Flat\_surface.py} define various geometric shapes used in the simulation. Each of these scripts inherits from the \texttt{Shape3D.py} class, which establishes a common structure and methods for geometric operations. This inheritance ensures that all shapes behave consistently under the simulation protocols and can be used interchangeably with the same set of operations, particularly with \texttt{Intersection.py}.

\texttt{STLFigure.py} plays a pivotal role in the system by facilitating both the import and export of 3D models in the STL format. This functionality allows users not only to export simulated shapes for 3D printing but also to import existing STL files into the simulation for further analysis. The script ensures that conversions maintain the structural integrity of 3D models, preparing them for both digital simulation and physical reproduction.

\paragraph{Intersection Calculations}
\texttt{Intersection.py} is crucial for the simulation as it calculates the points of intersection between two \texttt{Shape3D} objects. This capability is vital for simulating how light interacts with different surfaces, affecting the resulting interference patterns. By leveraging polymorphism, \texttt{Intersection.py} can operate on any objects derived from \texttt{Shape3D}, allowing for flexibility and extensibility in the types of objects and interactions that can be simulated. The algorithm is explained in the following flowchart.

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2cm]
\node (start) [startstop] {Start};
\node (in1) [io, below of=start] {Input: shape1, shape2};
\node (pro1) [process, below of=in1] {Get surface points for both shapes};
\node (dec1) [decision, below of=pro1, yshift=-1.5cm] {Point within surface bounds?};
\node (pro2a) [process, below of=dec1, yshift=-1.5cm] {Find closest indices in surface grid};
\node (dec2) [decision, below of=pro2a, yshift=-1cm] {Z-value intersection?};
\node (pro2b) [process, below of=dec2, yshift=-1cm] {Record intersection point};
\node (out1) [io, below of=pro2b] {Output: intersection points};
\node (stop) [startstop, below of=out1] {Stop};

\draw [arrow] (start) -- (in1);
\draw [arrow] (in1) -- (pro1);
\draw [arrow] (pro1) -- (dec1);
\draw [arrow] (dec1) -- node[anchor=east] {yes} (pro2a);
\draw [arrow] (dec1.east) -- ++(3,0) node[anchor=west] {no} |- (pro1.east);
\draw [arrow] (pro2a) -- (dec2);
\draw [arrow] (dec2) -- node[anchor=east] {yes} (pro2b);
\draw [arrow] (dec2.east) -- ++(3,0) node[anchor=west] {no} |- (pro2a.east);
\draw [arrow] (pro2b) -- (out1);
\draw [arrow] (out1) -- (stop);
\end{tikzpicture}
\caption{Flowchart of the Intersection Calculation Process}
\label{fig:flowchart1}
\end{figure}


\subsubsection{Graphical User Interface (GUI)}
The GUI, developed primarily through \texttt{Gui.py}, is instrumental in allowing users to interactively modify simulation parameters and visualize results in real time. The GUI is structured into several tabs, each facilitating different aspects of the simulation:
\begin{itemize}
    \item \textbf{File Tab} - Manages file operations like saving and loading simulation states.
    \item \textbf{Insert Tab} - Allows users to insert objects into the simulation environment. This tab includes multiple subtabs for each type of object that can be inserted, such as cylinders, disks, flat surfaces, and STL figures. Each subtab provides specialized controls and parameters appropriate for the specific type of object being added to the simulation.
    \item \textbf{View Tab} - Controls the visualization settings and perspectives.
    \item \textbf{3D View Tab} - Provides a dynamic 3D visualization of the simulated environment. This tab allows users to view and interact with the 3D models they have inserted or created within the simulation. Users can rotate, zoom, and pan across different views to better understand the spatial relationships and geometry of the objects. The 3D View Tab is crucial for assessing the accuracy of the simulation and for making real-time adjustments to the models.
    \item \textbf{Help Tab} - Provides user assistance and documentation on how to use the simulation tools.
    \item \textbf{Log Tab} - Records and displays logs of user actions and system responses for troubleshooting and instructional purposes.
\end{itemize}
This modular design ensures that users can easily navigate and utilize the simulation, enhancing both usability and educational value.

\end{document}
